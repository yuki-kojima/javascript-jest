# テスト駆動開発

## TDDとは
- 「動作する綺麗なコード」がTDDのゴール
- プログラマが自信を持って着実に「動作する綺麗なコード」に向かっていけるためのテクニック
- 分割統治する
 - 動作するコード　と　綺麗なコード　の二つに分けて一つずつ倒していく

### サイクル
- red green refactoring のサイクル
  - 1. 次の目標を考える
    -  今考えているものをテキストベースで書き出していく。TODOリストで箇条書きにすることが多い
    - 粒度は気にしない。まず頭の中のものをdumpする
    - リファクタリングを繰り返していく中で本来の目的を見失ったりしてしまうので整理しておく
    - サイクルの中でここに戻ってくる度にTODOを見直す
  - 2. その目標を示すテストを書く
    - 一番初めに倒すものを決めて取り掛かる
    - 一番テスト容易性が高いものから優先して行うことを勧めている
     - 一周目が一番重いので。まっさらな状態から始めるためテストの設計含めて必要になる
      - 一番初めに絶対に落ちるテストを書いて予想通りに落ちるかを確認し、テスティングフレームワークがしっかり動いていることを確認する
    - 慣れていくとテスト重要度とテスト容易性は比例していく(重要性が高いと容易性も高いはず)
  - 3. そのテストを実行して失敗させる(Red)
    - ユーザー観点でテストを実装する
  - 4. 目的のコードを書く
    - まずは成功させることに集中する
    - ひどいコードでもいいから、最短距離で実装する（仮実装）
      - テストが予期せぬ結果になった場合の原因解明をしやすくする意味もある
      - テストコードのバグを検知するためにわざと実装コードに判別可能な誤りを入れて、予想通りにテストが落ちることを確認する。
        - 一番最初にテストのテストをするために行う。一番初めにするのが一番コストが低い
        - diffect insertion
          - cf. mutation testing
    - 綺麗に書くことは一旦忘れるので時間そんなにかからないはず
  - 5. 2で書いたテストを成功させる(Green)
  - 6. テストが通るままでリファクタリングを行う(Refactor)
    - リファクタリングの定義を Kent Beck は「ソフトフェアの外部の振る舞いが変わらないまま内部を綺麗にしていくこと」→「成功しているテストが成功しているままで・・」に狭めた。
    - リファクタリングの失敗判断がテストのフェイルでわかるのでロールバックの基準が明確に
    - 動作するコードを動作するままで綺麗にしていく
    - リファクタリングのチャンスはサイクルを回すたびにあるので深追いしすぎない
      - 5-10min やったら、や除去した重複の数で切り上げるタイミング決める
  - 7. 1~6を繰り返す

## TDDのスキルまとめ
- 問題を小さく分割する
- 歩幅を調整する
 -  テスト -> 仮実装 -> 三角測量 -> 実装
 -  テスト -> 仮実装 -> 実装
 -  テスト -> 明白な実装
- テストの構造化とリファクタリング

## ライブコーディング
- テストの構造は４つ。4 phase テストと呼ばれたりする
  - 準備(Arrange)
  - 実行(Act)
  - 検証(Assert)
  - （後片付け）
- TDDではお尻から書いていく
- 実行
  - 作る前に使うこと。ユーザーのように
  - 作りやすいコードよりも使いやすいコードが大切
  - 使いやすいコードは作りにくいことが多い。作る前に使うことで使いやすさを優先する
-  テストケース内に複数のassertを置くのはアンチパターン
 - assertion ルーレット（ロシアン的な
  - 失敗した時にどこでこけたかをデバックしなきゃいけない
  - そのテストで何がしたかったのか分かりづらい
    - ドキュメントとして読んだ時に仕様が分かりづらい
- タスク分解のスキル
  - テストのしやすさ、しにくさがわかるようになるとうまく分解できる
  - クリーンアーキテクチャ" 「入出力からの遠さ」
  - 抽象度を下げていきながら行う
- テストの順番や他のテストに依存しないようにすること
  - テスティングフレームワークによってはテスト実行順序をあらかじめ散らしている
- テスト駆動開発の成果物は仕様書として動作するドキュメントですべき
  - 仕様レベルの言葉を使う
  - TDDのサイクルお初めの方でテストを抽象度を上げて進めるが、その後にテスト名を見直す癖をつけること
  -  仕様のツリー構造をテストコードにも適用する

## テストの構造化とリファクタリング
- テストを実装した補任が行うべき
- 後になっても動作するテストであるために。負の遺産にならないようにテストの構造・実装内容が頭に残っているうちに行う
- 仕様レベルの構造をテストで立体化しておくこと
- 不要なテストは消しておく（三角測量のためだけのコードなど）

# ハンズオン
- テストの書き方
  - ①必要最小限のコードを書いてメンテコストを削減し、テストを実装しやすくする→開発をゴリゴリしていく
  - ②品質保証観点: 対象ソフトウェアがどんな仕様か、その仕様に対して適したテストがもれなく書かれているか→品質保証に重きを置いている
- ブラックボックステストの観点: 実装コードを見ずに、仕様・テストがちゃんとされているかがわかるか
- 開発の途中から品質保証は始まっているべき。実装中も品質保証観点を持つことが大事
- 模範解答①は必要最小限のテスト。倍数のテストが1ケースしかない
  - テストケースを増やす =  テストコードを増やす = メンテ対象が増える = 保守コストが下がる。それに見合ったテストか？を考える。
  - → 品質保証観点では、仕様の範囲の際の値（境界値）をテストできるといい
    - 今回のケースは 1, 100が境界値。その付近の値をテストするのが良い（内側、外側）
    - その狙いの背景はテストケース名できちんと明文化すること
- テスト実装はテスト設計スキルも大事。ソフトウェアテスト技法
  - ソフトウェアテスト技法練習帳
  - ソフトウェアテスト技法ドリル
- 1-100 以外の値は？
  - 自分がプロダクトオーナーだった場合、関数の機能としては同じルールで機能することが好ましい（1-100はアプリケーション側の制約)
  - 0 の場合は？3の倍数でも5の倍数でもある